#!/usr/bin/env python3
"""
Convert web files to embedded C++ byte arrays for ESP32
Similar to WLED's approach - no SPIFFS needed
"""

import os
import sys
from pathlib import Path

def file_to_cpp_array(file_path, var_name):
    """Convert a file to a C++ byte array"""
    with open(file_path, 'rb') as f:
        data = f.read()
    
    # Create C++ array declaration
    cpp = f"// Embedded file: {file_path}\n"
    cpp += f"const char {var_name}[] PROGMEM = {{\n"
    
    # Convert bytes to hex array
    for i, byte in enumerate(data):
        if i % 16 == 0:
            cpp += "  "
        cpp += f"0x{byte:02x},"
        if i % 16 == 15:
            cpp += "\n"
        else:
            cpp += " "
    
    if len(data) % 16 != 0:
        cpp += "\n"
    
    cpp += "};\n"
    cpp += f"const size_t {var_name}_len = {len(data)};\n\n"
    
    return cpp

def get_content_type(file_path):
    """Get MIME content type for file"""
    ext = Path(file_path).suffix.lower()
    types = {
        '.html': 'text/html',
        '.css': 'text/css', 
        '.js': 'application/javascript',
        '.json': 'application/json',
        '.ico': 'image/x-icon',
        '.png': 'image/png',
        '.jpg': 'image/jpeg',
        '.svg': 'image/svg+xml'
    }
    return types.get(ext, 'application/octet-stream')

def main():
    # Paths
    data_dir = Path(__file__).parent.parent / "data"
    output_file = Path(__file__).parent.parent / "src" / "webfiles.h"
    
    if not data_dir.exists():
        print(f"Error: {data_dir} does not exist")
        sys.exit(1)
    
    print(f"Embedding web files from {data_dir}")
    print(f"Output: {output_file}")
    
    # Find all files to embed
    files_to_embed = []
    for file_path in data_dir.rglob('*'):
        if file_path.is_file():
            relative_path = file_path.relative_to(data_dir)
            files_to_embed.append((file_path, relative_path))
    
    # Generate C++ header
    cpp_content = """// Auto-generated embedded web files
// Generated by scripts/embed_files.py - DO NOT EDIT MANUALLY

#pragma once
#include <Arduino.h>

"""
    
    # Generate file mappings
    file_mappings = []
    
    for file_path, relative_path in files_to_embed:
        # Create variable name (replace special chars with underscores)
        var_name = str(relative_path).replace('/', '_').replace('.', '_').replace('-', '_')
        
        print(f"  Embedding: /{relative_path} -> {var_name}")
        
        # Add file array
        cpp_content += file_to_cpp_array(file_path, var_name)
        
        # Add to mapping
        url_path = "/" + str(relative_path).replace('\\', '/')
        content_type = get_content_type(file_path)
        file_mappings.append((url_path, var_name, content_type))
    
    # Generate lookup structure
    cpp_content += "// File mapping structure\n"
    cpp_content += "struct EmbeddedFile {\n"
    cpp_content += "    const char* path;\n"
    cpp_content += "    const char* data;\n"
    cpp_content += "    size_t length;\n"
    cpp_content += "    const char* contentType;\n"
    cpp_content += "};\n\n"
    
    cpp_content += f"const EmbeddedFile embeddedFiles[] = {{\n"
    for url_path, var_name, content_type in file_mappings:
        cpp_content += f'    {{"{url_path}", {var_name}, {var_name}_len, "{content_type}"}},\n'
    cpp_content += "};\n\n"
    
    cpp_content += f"const size_t embeddedFilesCount = {len(file_mappings)};\n"
    
    # Write output file
    with open(output_file, 'w') as f:
        f.write(cpp_content)
    
    print(f"Generated {len(file_mappings)} embedded files in {output_file}")

if __name__ == "__main__":
    main()